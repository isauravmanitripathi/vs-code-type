{
  "rootFolder": "Statistics-demo",
  "globalTypingSpeed": 35,
  "actionDelay": 1000,
  "defaultVoice": "en-US-BrianNeural",
  "enableVoiceover": true,
  "actions": [
    {
      "type": "createFile",
      "path": "Statistics.py",
      "voiceover": "Let's create the Statistics.py file.",
      "voiceoverTiming": "before"
    },
    {
      "type": "openFile",
      "path": "Statistics.py"
    },
    {
      "type": "writeText",
      "content": "import pandas as pd\nimport numpy as np\nimport scipy.stats\n"
    },
    {
      "type": "writeText",
      "content": "\n"
    },
    {
      "type": "writeText",
      "content": "\n"
    },
    {
      "type": "writeText",
      "content": "class Statistics:\n",
      "highlight": true,
      "voiceover": "This module provides a comprehensive statistical analysis toolkit for evaluating trading strategy performance in the stock market forecasting system. The Statistics class is used across all six main trading scripts (train_nextday_rf.py, train_nextday_lstm.py, train_intraday_rf.py, train_intraday_lstm.py, train_intraday_rf_multi.py, and train_intraday_lstm_multi.py) to compute various financial metrics that quantify the effectiveness and risk profile of the algorithmic trading strategies. After each backtesting run, the trading scripts pass a series of daily returns to this class, which then calculates key performance indicators such as mean returns, volatility, Sharpe ratio, Value at Risk, and maximum drawdown. These metrics help researchers and traders understand not just the profitability of a strategy, but also its risk characteristics, consistency, and robustness across different market conditions.\n\nThe Statistics class is a comprehensive financial performance analysis tool that takes a time series of returns (typically daily trading returns) and computes a wide range of statistical and risk metrics. This class is instantiated in all six trading scripts after the simulate function generates daily returns from the backtested trading strategy. The class stores the return series as a numpy array and provides methods to calculate various performance metrics including central tendency measures (mean), dispersion measures (standard deviation, standard error), distribution shape characteristics (skewness, kurtosis), risk metrics (Value at Risk, Conditional Value at Risk, Maximum Drawdown), and risk-adjusted performance measures (Sharpe ratio). The class is designed to work with percentage returns and automatically handles the conversion and annualization of metrics where appropriate. Each trading script uses this class by calling Statistics(returns.sum(axis=1)) where returns is a DataFrame containing 'Long' and 'Short' columns representing the daily returns from long and short positions respectively, and the sum combines them into a single daily return series for comprehensive performance evaluation.",
      "voiceoverTiming": "during"
    },
    {
      "type": "writeText",
      "content": "    def __init__(self,series):\n        self.series = np.array(series)\n        self.n = len(series)\n",
      "highlight": true,
      "voiceover": "The constructor method initializes a Statistics object by accepting a series of returns as input and storing it for subsequent analysis. This method is called automatically when creating a new Statistics instance in the trading scripts, typically with the combined daily returns from both long and short positions. The method first converts the input series into a numpy array to ensure consistent numerical operations regardless of whether the input is a pandas Series, list, or other iterable type. It then stores the length of the series in the instance variable n, which is used by various other methods to calculate percentages and indices. For example, when a trading script calls Statistics(returns.sum(axis=1)), this constructor receives the summed daily returns, converts them to a numpy array, and counts how many trading days are in the series, making this information readily available for all subsequent statistical calculations without needing to recompute it.",
      "voiceoverTiming": "during"
    },
    {
      "type": "writeText",
      "content": "    def mean(self):\n        return np.mean(self.series)\n",
      "highlight": true,
      "voiceover": "The mean method calculates and returns the arithmetic average of all returns in the series, representing the expected daily return of the trading strategy. This is one of the most fundamental performance metrics used in finance, as it tells us on average how much profit or loss the strategy generates per trading day. The method uses numpy's mean function which sums all the values in the series and divides by the count, giving us the central tendency of the return distribution. This metric is used extensively in the trading scripts' output files where it's saved to the avg_returns.txt file for each test year, and it's also a key component in calculating the Sharpe ratio. For instance, if the mean returns 0.0005, it means the strategy earns an average of 0.05 percent per day, which when annualized over approximately 252 trading days would represent a significant annual return. The mean is called by the shortreport and report methods to display performance summaries, and it's also used internally by the sharpe method to compute risk-adjusted returns.",
      "voiceoverTiming": "during"
    },
    {
      "type": "writeText",
      "content": "    def std(self):\n        return np.std(self.series)\n",
      "highlight": true,
      "voiceover": "The std method computes the standard deviation of the return series, which measures the volatility or risk of the trading strategy by quantifying how much the daily returns deviate from their mean value. Standard deviation is a critical risk metric in finance because it captures the uncertainty and variability in returns, with higher values indicating more volatile and potentially riskier strategies. The method uses numpy's std function which calculates the square root of the variance, where variance is the average of the squared differences from the mean. This metric appears in both the shortreport and report output methods and is also used as the denominator in the Sharpe ratio calculation, making it essential for risk-adjusted performance evaluation. For example, if the standard deviation is 0.02, it means that on a typical day, the strategy's return deviates from its average by about 2 percent in either direction. A strategy with high mean returns but also high standard deviation might be less desirable than one with moderate returns and low volatility, which is why this metric is always considered alongside the mean when evaluating trading performance.",
      "voiceoverTiming": "during"
    },
    {
      "type": "writeText",
      "content": "    def stderr(self):\n        return scipy.stats.sem(self.series)\n",
      "highlight": true,
      "voiceover": "The stderr method calculates the standard error of the mean, which quantifies the precision of the sample mean as an estimate of the true population mean of returns. Unlike standard deviation which measures the variability of individual returns, standard error measures how much the calculated mean might vary if we were to repeat the trading experiment with different time periods. The method uses scipy's sem function which computes the standard error by dividing the standard deviation by the square root of the sample size, following the formula stderr equals sigma divided by square root of n. This metric is particularly useful for statistical inference and hypothesis testing, as it helps determine whether the observed mean return is significantly different from zero or from other benchmarks. The standard error appears in the comprehensive report method output and becomes smaller as the number of observations increases, reflecting greater confidence in the estimated mean. For instance, with 252 trading days in a year, the standard error would be the daily standard deviation divided by the square root of 252, which is approximately 15.87, giving us a measure of how reliable our annual performance estimate is based on daily observations.",
      "voiceoverTiming": "during"
    },
    {
      "type": "writeText",
      "content": "    def percentiles(self,p=[.25,.5,.75]):\n        return pd.Series(self.series).describe(percentiles=p)\n",
      "highlight": true,
      "voiceover": "The percentiles method generates a comprehensive statistical summary of the return distribution including count, mean, standard deviation, minimum, maximum, and specified percentile values, providing a complete picture of how returns are distributed across their range. By default, it calculates the 25th percentile (first quartile), 50th percentile (median), and 75th percentile (third quartile), which divide the sorted returns into four equal parts and help identify the spread and symmetry of the distribution. The method converts the numpy array to a pandas Series and calls the describe function with custom percentiles, which internally sorts the data and finds the values at the specified positions. This is particularly useful for understanding the full distribution of returns beyond just mean and standard deviation, as it reveals whether returns are symmetric or skewed, and whether there are extreme outliers. The output appears in the comprehensive report method and helps traders understand questions like what return can be expected on a typical good day versus a typical bad day, or what percentage of days fall within certain return ranges. For example, if the 25th percentile is negative 1 percent and the 75th percentile is positive 1.5 percent, it tells us that the middle 50 percent of trading days had returns between these values, with 25 percent of days performing worse and 25 percent performing better.",
      "voiceoverTiming": "during"
    },
    {
      "type": "writeText",
      "content": "    def pos_perc(self):\n        return 100*sum(self.series>0)/self.n\n",
      "highlight": true,
      "voiceover": "The pos_perc method calculates the percentage of trading days that generated positive returns, which is an important measure of the strategy's consistency and win rate. This metric works by creating a boolean array where each element is True if the corresponding return is greater than zero and False otherwise, then summing these boolean values (where True counts as 1 and False as 0) to get the total number of profitable days, and finally dividing by the total number of days and multiplying by 100 to convert to a percentage. A strategy with a high positive percentage (above 50 percent) wins more often than it loses, though this doesn't necessarily mean it's more profitable overall since the magnitude of wins and losses also matters. This metric appears in the comprehensive report output and helps assess the psychological comfort of a trading strategy, as strategies with very low win rates can be difficult to follow even if they're ultimately profitable due to occasional large wins. For example, if pos_perc returns 58.5, it means that on 58.5 percent of trading days the strategy made money, while on 41.5 percent of days it lost money, suggesting a moderately consistent strategy that wins slightly more often than it loses, which can be important for trader confidence and strategy adherence over long periods.",
      "voiceoverTiming": "during"
    },
    {
      "type": "writeText",
      "content": "    def skewness(self):\n        return scipy.stats.skew(self.series)\n",
      "highlight": true,
      "voiceover": "The skewness method measures the asymmetry of the return distribution, indicating whether returns are more likely to have extreme values on the positive or negative side. This metric uses scipy's skew function which calculates the third standardized moment of the distribution, where a skewness of zero indicates a perfectly symmetric distribution like the normal distribution, positive skewness indicates a distribution with a long right tail (more extreme positive returns), and negative skewness indicates a long left tail (more extreme negative returns). In trading, positive skewness is generally desirable because it means the strategy occasionally generates very large positive returns while losses tend to be more moderate, whereas negative skewness suggests the opposite pattern of occasional catastrophic losses. The skewness value appears in the comprehensive report output and helps traders understand the shape of their return distribution beyond just mean and variance. For example, a skewness of negative 0.5 would indicate a moderately left-skewed distribution where extreme losses are more common than extreme gains, which might be concerning for risk management, while a skewness of positive 1.2 would suggest a right-skewed distribution with occasional very profitable days, which is often preferred in trading strategies as it aligns with the goal of cutting losses short and letting winners run.",
      "voiceoverTiming": "during"
    },
    {
      "type": "writeText",
      "content": "    def kurtosis(self):\n        return scipy.stats.kurtosis(self.series)\n",
      "highlight": true,
      "voiceover": "The kurtosis method measures the tailedness of the return distribution, specifically quantifying how much probability mass is in the extreme tails compared to a normal distribution, which is crucial for understanding the likelihood of extreme events or outliers. This method uses scipy's kurtosis function which calculates the fourth standardized moment and returns excess kurtosis (kurtosis minus 3), where a value of zero indicates tails similar to a normal distribution, positive values indicate heavier tails with more extreme outliers (leptokurtic), and negative values indicate lighter tails with fewer extremes (platykurtic). In financial markets, return distributions typically exhibit positive excess kurtosis, meaning extreme events (both gains and losses) occur more frequently than a normal distribution would predict, which has important implications for risk management and position sizing. The kurtosis value appears in the comprehensive report output and helps traders assess tail risk and the adequacy of risk models based on normal distribution assumptions. For instance, an excess kurtosis of 3.0 indicates significantly fatter tails than normal, suggesting that extreme daily returns (both very large gains and very large losses) happen much more often than would be expected under normality, which means risk metrics like standard deviation might underestimate the true risk of rare but severe losses, and traders should be prepared for occasional extreme movements beyond what typical volatility measures suggest.",
      "voiceoverTiming": "during"
    },
    {
      "type": "writeText",
      "content": "    def VaR(self,confidence):\n        indx = int(confidence*self.n/100)\n        return sorted(self.series)[indx-1]\n",
      "highlight": true,
      "voiceover": "The VaR method calculates Value at Risk at a specified confidence level, which represents the maximum expected loss over a single trading day at that confidence level, making it one of the most widely used risk metrics in finance. The method works by first calculating the index position corresponding to the confidence level (for example, 5 percent confidence means we want the 5th percentile), then sorting all returns from worst to best, and finally returning the return value at that index position. This tells us that on the worst X percent of days, the loss was at least this bad, or conversely, that 100 minus X percent of days had returns better than this value. The method is called three times in the comprehensive report with confidence levels of 1, 2, and 5 percent to show increasingly severe tail risks. For example, if VaR(5) returns negative 0.03, it means that on the worst 5 percent of trading days, the strategy lost at least 3 percent, or equivalently, there's a 5 percent chance on any given day of losing 3 percent or more. This metric is crucial for risk management and capital allocation decisions, as it provides a concrete number for potential losses that can be used to set position sizes, stop losses, and overall portfolio risk limits, though it's important to note that VaR only tells us the threshold value and not how bad losses might be beyond that threshold.",
      "voiceoverTiming": "during"
    },
    {
      "type": "writeText",
      "content": "    def CVaR(self,confidence):\n        indx = int(confidence*self.n/100)\n        return sum(sorted(self.series)[:indx])/indx\n",
      "highlight": true,
      "voiceover": "The CVaR method calculates Conditional Value at Risk, also known as Expected Shortfall, which measures the average loss on the worst X percent of trading days, providing a more comprehensive risk measure than VaR by considering not just the threshold but the severity of losses beyond it. The method works by first determining the index corresponding to the confidence level, then sorting all returns from worst to best, selecting only the worst X percent of returns (all values up to that index), and finally computing their average. This addresses a key limitation of VaR by answering the question of how bad things get when they do go bad, rather than just identifying the threshold. The method is called three times in the comprehensive report with confidence levels of 1, 2, and 5 percent to show the expected loss conditional on being in the worst tail of the distribution. For example, if CVaR(5) returns negative 0.045, it means that on the worst 5 percent of trading days, the average loss was 4.5 percent, which is typically worse than the VaR(5) value because it includes days that were even worse than the 5th percentile threshold. This metric is particularly valuable for risk management because it captures tail risk more completely, is more sensitive to the shape of the loss distribution, and provides a better estimate of potential losses during crisis periods, making it preferred by many risk managers over VaR alone for setting capital requirements and stress testing trading strategies.",
      "voiceoverTiming": "during"
    },
    {
      "type": "writeText",
      "content": "    def MDD(self):\n        money = np.cumprod(1+self.series/100)\n        maximums = np.maximum.accumulate(money)\n        drawdowns = 1 - money/maximums\n        return np.max(drawdowns)\n",
      "highlight": true,
      "voiceover": "The MDD method calculates the Maximum Drawdown, which measures the largest peak-to-trough decline in cumulative returns over the entire time series, representing the worst possible loss an investor would have experienced if they had bought at the highest point and sold at the subsequent lowest point. The method works through several steps: first, it converts the percentage returns into a cumulative wealth series by adding 1 to each return (converting from percentage to growth factor), dividing by 100, and taking the cumulative product to simulate how one dollar would grow over time. Second, it uses numpy's maximum.accumulate function to create a series of running maximum values, where each point represents the highest cumulative wealth achieved up to that point in time. Third, it calculates the drawdown at each point by computing one minus the ratio of current wealth to the running maximum, which gives the percentage decline from the peak. Finally, it returns the maximum value from this drawdown series, representing the worst peak-to-trough loss. This metric appears in the comprehensive report output and is crucial for understanding the pain an investor would have endured during the worst period of the strategy. For example, if MDD returns 0.25, it means there was a period where the strategy lost 25 percent from its previous peak before recovering, which helps investors assess whether they could psychologically and financially withstand such a drawdown, and it's often used alongside Sharpe ratio to evaluate risk-adjusted performance since a strategy with high returns but also high maximum drawdown might be unsuitable for risk-averse investors.",
      "voiceoverTiming": "during"
    },
    {
      "type": "writeText",
      "content": "    def sharpe(self,risk_free_rate = 0.0003):\n        mu = self.mean()\n        sig = self.std()\n        sharpe_d = (mu-risk_free_rate)/sig\n        return (252**0.5)*sharpe_d \n",
      "highlight": true,
      "voiceover": "The sharpe method calculates the Sharpe ratio, which is the most widely used measure of risk-adjusted return in finance, quantifying how much excess return is earned per unit of risk taken. The method works by first calculating the mean daily return using the mean method, then calculating the daily standard deviation using the std method, then computing the daily Sharpe ratio by subtracting the risk-free rate from the mean and dividing by the standard deviation, and finally annualizing this daily Sharpe ratio by multiplying by the square root of 252 (the approximate number of trading days in a year). The default risk-free rate of 0.0003 represents 0.03 percent per day, which roughly corresponds to a 7.5 percent annual risk-free rate, though this can be adjusted based on current market conditions. The Sharpe ratio appears in both the shortreport and report outputs and is saved to the avg_returns.txt file for each test year, making it one of the primary metrics for comparing different trading strategies. For example, a Sharpe ratio of 2.0 is considered excellent and means the strategy earns 2 units of excess return for every unit of volatility risk, while a Sharpe ratio below 1.0 is generally considered poor. This metric is particularly valuable because it allows fair comparison between strategies with different return and risk profiles, penalizing strategies that achieve high returns only by taking excessive risk, and it's the key metric highlighted in the research paper's results to demonstrate that the LSTM and Random Forest strategies significantly outperform traditional buy-and-hold approaches on a risk-adjusted basis.",
      "voiceoverTiming": "during"
    },
    {
      "type": "writeText",
      "content": "    def shortreport(self):\n        print('Mean \\t\\t',self.mean())\n        print('Standard dev \\t',self.std())\n        print('Sharpe ratio \\t',self.sharpe())       \n",
      "highlight": true,
      "voiceover": "The shortreport method prints a concise summary of the three most important performance metrics: mean return, standard deviation, and Sharpe ratio, providing a quick overview of strategy performance without overwhelming detail. This method is called in all six trading scripts immediately after the simulate function generates returns and the Statistics object is created, displaying the results to the console during each year's backtesting run. The method uses tab characters for formatting to align the output in columns, making it easy to read and compare across different years. The three metrics shown represent the essential trade-off in investing: the mean shows how much return the strategy generates, the standard deviation shows how much risk is taken to achieve that return, and the Sharpe ratio combines both to show the risk-adjusted performance. This abbreviated report is preferred during the backtesting loop because it provides immediate feedback on performance without cluttering the console with excessive detail, allowing researchers to quickly identify which years performed well or poorly. For example, during a backtesting run, the output might show Mean equals 0.0008, Standard dev equals 0.015, and Sharpe ratio equals 2.1, immediately telling the researcher that this particular year generated strong risk-adjusted returns, and this information is also saved to the avg_returns.txt file for permanent record keeping and later analysis.",
      "voiceoverTiming": "during"
    },
    {
      "type": "writeText",
      "content": "    def report(self):\n        print('Mean \\t\\t',self.mean())\n        print('Standard dev \\t',self.std())\n        print('Sharpe ratio \\t',self.sharpe())\n        print('Standard Error \\t',self.stderr())\n        print('Share>0 \\t',self.pos_perc())\n        print('Skewness \\t',self.skewness())\n        print('Kurtosis \\t',self.kurtosis())\n        print('VaR_1 \\t\\t',self.VaR(1))\n        print('VaR_2 \\t\\t',self.VaR(2))\n        print('VaR_5 \\t\\t',self.VaR(5))\n        print('CVaR_1 \\t\\t',self.CVaR(1))\n        print('CVaR_2 \\t\\t',self.CVaR(2))\n        print('CVaR_5 \\t\\t',self.CVaR(5))\n        print('MDD \\t\\t',self.MDD())\n        print(self.percentiles())\n",
      "highlight": true,
      "voiceover": "The report method prints a comprehensive statistical summary including all available metrics, providing a complete picture of the trading strategy's performance characteristics, risk profile, and return distribution properties. This method calls every other method in the Statistics class to generate a full report that includes basic statistics (mean, standard deviation, standard error), risk-adjusted performance (Sharpe ratio), consistency measures (percentage of positive days), distribution shape characteristics (skewness and kurtosis), tail risk metrics (Value at Risk and Conditional Value at Risk at multiple confidence levels), drawdown analysis (maximum drawdown), and distributional summaries (percentiles). While this method is defined in the class, it's not actually called in the current trading scripts which prefer the more concise shortreport method, but it's available for detailed analysis when researchers want to deeply understand a particular strategy's performance. The method uses tab characters for alignment and prints each metric on a separate line for easy reading. For example, a complete report might show that a strategy has a mean of 0.0008, standard deviation of 0.015, Sharpe ratio of 2.1, standard error of 0.0009, 58 percent positive days, skewness of 0.3 (slight positive skew), kurtosis of 2.5 (fat tails), VaR values showing the worst 1, 2, and 5 percent of days, CVaR values showing average losses in those tails, maximum drawdown of 18 percent, and percentile information showing the full distribution, giving researchers everything they need to understand not just whether the strategy is profitable but also how it achieves those profits, what risks it takes, and whether it would be suitable for actual trading given psychological and capital constraints.",
      "voiceoverTiming": "during"
    }
  ]
}